"""
Cargo validator utility
"""
import os
import logging

import toml

LOG = logging.getLogger(__name__)


class PackagerError(Exception):
    pass


class CargoFileNotFoundError(PackagerError):
    def __init__(self, cargo_path):
        super(CargoFileNotFoundError, self).__init__(
            'Cargo file not found: %s' % cargo_path)


class CargoParsingError(PackagerError):
    def __init__(self, ex):
        super(CargoParsingError, self).__init__(
            'Could not parse cargo file: %s' % ex)


class CargoValidationError(PackagerError):
    def __init__(self, msg):
        super(CargoValidationError, self).__init__(
            'Invalid cargo file: %s' % msg)


class PathNotFoundError(PackagerError):
    def __init__(self, bin_path):
        super(PathNotFoundError, self).__init__(
            'Path not found: %s' % bin_path)


class CargoParser(object):
    def __init__(self, manifest):
        """
        Given the path to a Cargo.toml file parses its contents. Use
        the validate() method sanity-check the cargo manifest for
        a Lambda function build.

        :raises CargoParsingError: If the Cargo.toml file could not be
            found or parsed.
        """
        self.manifest = manifest
        self._parse(manifest)

    def _parse(self, manifest):
        if not os.path.isfile(manifest):
            raise CargoFileNotFoundError(manifest)

        try:
            with open(manifest, 'r') as cargo:
                package_properties = toml.load(cargo)
                LOG.debug("Cargo file: %s", package_properties)
                self.cargo = package_properties
        except (TypeError, toml.TomlDecodeError) as ex:
            raise CargoParsingError(ex)
        except ValueError as ex:
            raise CargoParsingError(ex)

    def get_executable_name(self):
        """
        Returns the name of the executable file generated by the
        cargo build process
        """
        self.validate(print_warnings=False)

        bin_name = self.cargo["package"]["name"]
        if "bin" in self.cargo:
            bin_props = self.cargo["bin"]
            for prop in bin_props:
                if "name" in prop:
                    bin_name = prop["name"]

        return bin_name

    def get_target_path(self, target_platform):
        """
        Returns the full path to the target directory where the binary is stored

        :type target_platform: str
        :param target_platform:
            The --target parameter that was passed to the cargo build process.

        :raise ExecutableNotFound: If the executable file does not exist.
        """
        self.validate(print_warnings=False)
        proj_path = os.path.dirname(os.path.abspath(self.manifest))
        target_dir = os.path.join(proj_path, "target", target_platform, "release")

        if not os.path.isdir(target_dir):
            raise PathNotFoundError(target_dir)

        return target_dir

    def get_executable_path(self, target_platform):
        """
        Returns the full path to the compiled executable.

        :type target_platform: str
        :param target_platform:
            The --target parameter that was passed to the cargo build process.

        :raise ExecutableNotFound: If the executable file does not exist.
        """
        self.validate(print_warnings=False)

        bin_name = self.get_executable_name()
        proj_path = os.path.dirname(os.path.abspath(self.manifest))
        bin_full_path = os.path.join(proj_path, "target", target_platform, "release", bin_name)

        if not os.path.isfile(bin_full_path):
            raise PathNotFoundError(bin_full_path)

        return bin_full_path

    def validate(self, print_warnings=True):
        """
        Validates a Cargo.toml file and optionally prints out warnings
        and suggestions for the Cargo structure.

        :type print_warnings: bool
        :param print_warnings:
            Whether the method should print warnings in the LOG object.

        :raise CargoValidationError: If the cargo file was not parsed correctly
            or it does not represent a valid package.
        """
        if not self.cargo:
            raise CargoValidationError("Cargo file not parsed")

        if "package" not in self.cargo:
            raise CargoValidationError("Manifest does not contain package table")

        package = self.cargo["package"]
        if "name" not in package:
            raise CargoValidationError("Missing name property for package")

        if "bin" not in self.cargo:
            if print_warnings:
                LOG.warning(("Missing [[bin]] section from Cargo.toml. "
                             "The builder will rename the executable from %s "
                             "to bootstrap. Consider including a [[bin]] "
                             "section in the Cargo.toml file with a "
                             "name = \"bootstrap\" property."), package["name"])
        else:
            bin_props = self.cargo["bin"]
            name_found = False
            for prop in bin_props:
                if "name" in prop:
                    name_found = True
                    break

            if not name_found and print_warnings:
                LOG.warning(("Missing name property from [[bin]] section "
                             "in Cargo.toml file. Consider including a name "
                             "property and setting its value to bootstrap. This "
                             "is the executable name AWS Lambda expects."))

        if "dependencies" in self.cargo:
            deps = self.cargo["dependencies"]
            if "lambda_runtime" not in deps and print_warnings:
                LOG.warning("""lambda_runtime is not included as a dependency in
                            Your Cargo.toml file.""")
